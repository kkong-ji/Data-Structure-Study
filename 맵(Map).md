## 맵(Map)
- 데이터를 Key-Value(키-값)의 형식으로 저장하는 방식.
- `Key` 는 중복을 허용하지 않지만, `Value` 는 중복을 허용한다는 특징이 있음.  
ex. 주민번호(Key), 사람이름(Value)

<br>

### 1. 트리를 이용하여 구현
- 완전 이진 검색 트리의 각 노드에 Key와 Value를 저장하는 데이터를 추가하여 구현
- 원하는 값을 찾을 때, O(logN)의 시간복잡도로 찾을 수 있으며 트리에 값을 추가할 때도 O(logN)

<br>

### 2. 해시를 이용하여 구현
- 해시를 이용한 맵은 해시화(해싱)한 Key를 통해 `Key - Value` 를 저장해둔 자료구조
> `해싱(Hasing)` <br>
>  : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 변경한 값

<br>

<해싱의 예>
<br>
숫자 1, 2, 3, 4, 5가 있고 입력된 숫자를 3으로 나눈 나머지 값을 해싱으로 설정한다고 하면

|숫자|해시값|
|--|--|
|1|1|
|2|2|
|3|0|
|4|1|
|5|2|

숫자 1을 해싱에 입력하면 해시값은 항상 1 <br>
숫자 3을 해싱에 입력하면 해시값은 항상 0 <br>
숫자 4를 해싱에 입력하면 해시값은 항상 1 <br>

<br>

### 2-1. 해싱의 단점
1. 해싱을 `10억으로 나눈 나머지`로 한다면?  
-> 10억 이하의 수는 모두 다른 해시값을 가질 것  
-> but, 메모리를 너무 많이 사용

2. 해싱을 `3으로 나눈 나머지`로 한다면?  
-> 메모리는 Ok.  
-> but, 중복되는 해시값이 너무 많음.

> 📌 이러한 문제점을 해결하기 위해 체이닝, 오픈 어드레싱 방법 사용

<br>

### 3. 체이닝 방식
- 동일한 해시값으로 인한 해시 충돌이 발생할 경우, 동일한 해시값에 해당하는 `Key` 끼리 서로 연결해가며  
저장해둔 방식

![image](https://user-images.githubusercontent.com/87354210/216488345-ef22045e-9c60-478f-ba4c-179f6d0d9291.png)

<br>

- '1-일구' 와 '4-사순이'는 해시 값이 같기 때문에, LinkedList 자료구조를 이용하여 해시값의 메모리  
   위치에 Key-Value 데이터를 하나씩 추가해서 서로 연결해가며 저장해둠.
- 동일한 Key값을 가지는 곳에 Value를 저장하기 위해 알맞은 구조.
- 해시값의 위치에 연결된 데이터가 많다면 최대 O(n)의 시간복잡도가 소요
- Key값에 Value를 추가할 때도 해시값을 이용한 메모리 장소에 삽입 (평균적으로 O(1)의 시간복잡도 소요)

<br>

### 4. 오픈 어드레싱 방식
- 해시값에 해당하는 메모리 위치에 Key-Value가 있다면 그 위치부터 탐색해가며 아무 값도 없는  
  위치에 Key-Value를 넣는 방식
  
![image](https://user-images.githubusercontent.com/87354210/216490028-9c789714-f11b-4697-949b-61ff6c0a0664.png)

<br>

- 이때, 다음 그림처럼 '6-육칠이'라는 Key-Value를 추가할 때 Key의 해시값은 0이므로 메모리 0부터  
  탐색해가며 Key값이 들어있지 않는 2번 위치에 Key-Value를 넣어주면 됨.

![image](https://user-images.githubusercontent.com/87354210/216490503-2394f102-d912-460c-bf09-b845ea17d863.png)

<br>

### 4-1. 오픈 어드레싱 방식의 단점
- 오픈 어드레싱 방식은 메모리를 효율적으로 사용할 수 있지만, 단점으로는 최악의 경우  
해시값의 충돌이 일어나 비어 있는 메모리 위치를 찾을 때 시간복잡도는 O(메모리의 크기)가 됨.  
(평균적으로는 O(1)의 시간복잡도)
